---
title: '第3章 k近邻法'
categories:
  - machine learning
date: 2017-5-27 17:45:22
tags:
---

$k$近邻法(k-nearest neighbor, k-NN)是一种基本分类与回归方法。本文只讨论分类问题中的$k$近邻法。

$k$近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。$k$值的选择、距离度量及分类决策规则是$k$近邻法的三个基本要素。

$k$近邻法没有显示的学习过程。

$k$近邻法的特殊情况是$k=1$的情形，称为最近邻算法。对于输入的实例点(特征向量)$x$，最近邻法将训练数据集中与$x$最邻近点的类作为$x$的类。

## 3\.1 $k$近邻算法

$k$近邻算法简单、直观：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的$k$个实例，这$k$个实例的多数属于某个类，就把该输入实例分为这个类。

**算法 3.1 (k近邻法)**  
输入：训练数据集 $$T=\lbrace (x_1,y_1),(x_2,y_2),\cdots,(x_n,y_N) \rbrace$$ 其中，$x_i\in \mathcal{X}\subseteq R^n$为实例的特征向量，$y_i\in\mathcal{Y}=\lbrace c_1,c_2,\cdots,c_k \rbrace$为实例的类别，$i=1,2,\cdots,N$；实例特征向量$x$；  
输出：实例$x$所属的类$y$。  
(1) 根据给定的距离度量，在训练集$T$中找出与$x$最近邻的$k$个点，涵盖这$k$个点的$x$的领域记作$N_k(x)$；  
(2) 在$N_k(x)$中根据分类决策规则(如多数表决)决定$x$的类别$y$；  
$$y=\underset{c_j}{\arg\max}\sum_{x_i\in N_k(X)}I(y_i=c_i),i=1,2,\cdots,N; j=1,2,\cdots,K$$ 其中，$I$为指示函数，即当$y_i=c_j$时$I$为1，否则$I$为0。

## 3\.2 $k$近邻模型

$k$近邻法中，当训练集、距离度量(如欧式距离)、$k$值及分类决策规则(如多数表决)确定后，对于任何一个新的输入实例，它所属的类唯一确定。

### 3\.2.1 模型

特征空间中，对每个训练实例点$x_i$，距离该点比其他点更近的所有点组成一个区域，叫作单元(cell)。每个训练实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个划分。最近邻法将实例$x_i$的类$y_i$作为单元中所有点的类标记(class label)。这样，每个单元的实例点的类别是确定的。

![k近邻的模型对应特征空间的一个划分][1]

### 3\.2.2 距离度量

特征空间中两个实例点的距离是两个实例点相似程度的反映。$k$近邻模型的特征空间一般是$n$维实数向量空间$R^n$。

设特征空间$\mathcal{X}$是$n$维实数向量空间$R^n$，$x_i,x_j\in\mathcal{X},x_i=\lgroup{{x_i}^{(1)}},{{x_i}^{(2)}},\cdots,{{x_i}^{(n)}} \rgroup ^T$,$x_j=\lgroup{{x_j}^{(1)}},{{x_j}^{(2)}},\cdots,{{x_j}^{(n)}} \rgroup ^T$的$L_p$距离定义为

$$ L_p(x_i,x_j) = {\lgroup \sum_{l=1}^{n} {|{x_i}^{(l)} - {x_j}^{(l)}|}^p \rgroup} ^ {\frac{1}{p}}$$

这里$p\ge 1$。当$p=2$时，称为**欧式距离(Euclidean distance)**，即

$$ L_p(x_i,x_j) = {\lgroup \sum_{l=1}^{n} {|{x_i}^{(l)} - {x_j}^{(l)}|}^2 \rgroup} ^ {\frac{1}{2}}$$

当$p=1$时，称为**曼哈顿距离(Manhattan distance)**，即 $$ L_p(x_i,x_j) = {\lgroup \sum_{l=1}^{n} {|{x_i}^{(l)} - {x_j}^{(l)}|} \rgroup}$$ 当$p=+\infty$时，它是各个坐标距离的最大值，即 $$L_{\infty}=\underset{l}{\max}|{x_i}^{(l)} - {x_j}^{(l)}|$$

下图给出了二维空间中$p$取不同值时，与原点的$L_p$距离为1 ($L_p=1$)的点的图形。

![L_p距离间的关系][2]

### 3\.2.3 $k$值的选择

$k$值的选择会对$k$近邻法的结果产生重大影响。

若选择较小的$k$值，就相当于用较小的领域中的训练实例进行预测，“学习”的近似误差(approximation error)会减小，只有与输入实例较近的(相似的)训练实例才会对预测结果起作用。但缺点时“学习”的估计误差(estimation error)会增大，预测的结果会对近邻的实例点非常敏感。若近邻的实例点恰巧是噪声，预测就会出错。即，$k$值的减少就意味着整体模型变得复杂，易发生过拟合。

> 关于**近似误差**与**估计误差**(还是没太懂):  
> 1\. <http://blog.csdn.net/linian8123654/article/details/53301207>  
> 2\. <https://www.zhihu.com/question/60793482>  
> 3\. <https://stats.stackexchange.com/questions/87750/what-does-the-term-estimation-error-mean/149922#149922>

若选择较大的$k$值，就相当于用较大领域中的训练实例进行预测。其优点是可以减少学习的估计误差。但缺点是学习的近似误差会增大。这时与输入实例较远的(不相似的)训练实例也会对预测起作用，使预测发生错误。$k$值的增大就意味着整体的模型变得简单。

若$k=N$，则无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型过于简单，完全忽略训练实例中的大量有用信息，是不可取的。

在应用中，$k$值一般取一个比较小的数值。通常采用交叉验证法来选取最优的$k$值。

### 3\.2.4 分类决策规则

$k$近邻法中的分类决策规则往往是多数表决，即由输入实例的$k$个邻近的训练实例中的多数类决定输入实例的类。

多数表决规则(majority voting rule)等价于经验风险最小化。

## 3\.3 $k$近邻法的实现:kd树

实现$k$近邻法时，主要考虑的问题是如何对训练数据进行快速$k$近邻搜索。这点在特征空间的维数大及训练数据容量大时尤其必要。

$k$近邻法最简单的实现方法是线性扫描(linear scan)。这时要计算输入实例与每一个训练实例的距离。当训练集很大时，计算非常耗时，这种方法是不可行的。

为了提高$k$近邻搜索的效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。如使用kd树(kd tree)。

### 3\.3.1 构造kd树

kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对$k$维空间的一个划分(partiton)。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每一个结点对应于一个k维超矩形区域。

构造kd树的方法如下：构造**根结点**，使根结点对应于k维空间中包含所有实例点的超矩形区域。通过下面的递归方法，不断地对k维空间进行切分，生成子结点。在超矩形区域(结点)上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐轴，将当前超矩形区域切分为左右两个子区域(子结点)；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止(终止时的结点为叶结点)。在此过程中，将实例保存在相应的结点上。

通常，依次选择坐标轴对空间切分，选择训练实例点在选定坐标轴上的中位数(median)为切分点，这样得到的kd树是平衡的。注意，平衡的kd树搜索时效率未必是最优的。

**算法3.2 (构造平衡kd树)**

输入：k维空间数据集$T=\lbrace x_1, x_2, \cdots, x_n \rbrace$，  
其中$x_i=({x_i}^{(1)}, {x_i}^{(2)}, \cdots, {x_i}^{(k)})^T,i=1,2,\cdots,N$;  
输出：kd树。

(1)开始：构造根结点，根结点对应于包含$T$的k维空间的超矩形区域。  
选择$x^{(1)}$为坐标轴，以$T$中所有实例的$x^{(1)}$坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。

由根结点生成深度为1的左、右子结点：左子结点对应坐标$x^{(1)}$小于切分点的子区域，右子结点对应坐标$x^{(1)}$大于切分点的子区域。

将落在切分超平面上的实例点保存在根结点。

(2) 重复：对深度为$j$的结点，选择$x^{(l)}$为切分的坐标轴，$l=j(mod k) + 1$，以该结点的区域中所有实例的$x^{(l)}$坐标的中位数为切分点，将该结点对应的超矩形区域切为两个子区域。切分由通过切分点并与坐标轴$x^{(l)}$垂直的超平面实现。

由该结点生成深度为$j+1$的左、右子结点：左子结点对应坐标$x^{(l)}$小于切分点的子区域，右子结点对应坐标$x^{(l)}$大于切分点的子区域。

将落在切分超平面上的实例点保存在该结点。

(3) 直到两个子区域上没有实例存在时停止。从而形成kd树的区域划分。

### 3\.3.2 搜索kd树

利用kd树进行k近邻搜索，可以省去大部分数据点的搜索，从而减少搜索的计算量。

给定一个目标点，搜索其最近邻。首先找到包含目标点的叶结点；然后从该叶结点出发，依次回退到父结点；不断查找与目标点最邻近的结点，当确定不可能存在更近的结点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。

包含目标点的叶结点对应包含目标点的最小超矩形区域。以此叶结点的实例点作为当前最近点。目标点的最近邻一定在以目标点为中心并通过当前最近点的超球体的内部。

**算法3.3 (用kd树的最近邻搜索)**

输入：已构造的kd树; 目标点x；  
输出：x的最近邻。

(1)在kd树中找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶子结点为止。  
(2)以此叶结点为“当前最近点”。  
(3)递归地向上回退，在每个结点进行以下操作：  
(a)若该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。  
(b)当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一个子结占对应的区域是否有更近的点。具体地，检查另一子结点对应的区域是否以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。

若相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点。接着，递归地进行最近邻搜索；

若不相交，向上回退。

(4)当回退到根结点时，搜索结束。最后的“当前最近点”即为x的最近点。

若实例点是随机分布的，kd树搜索的平均计算复杂度是$O(logN)$，这里$N$是**训练实例数**。kd树更适用于训练实例数远大于空间维数时的k近邻搜索。当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。

![][3]

 [1]: http://oqfqjieze.bkt.clouddn.com/k-neighbor.png
 [2]: http://oqfqjieze.bkt.clouddn.com/blog/L_p_distance.png
 [3]: http://oqfqjieze.bkt.clouddn.com/blog/kd_tree.png